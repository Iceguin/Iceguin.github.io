<!DOCTYPE html>
<html>
	<head>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
		<script type="text/javascript">

			const tagsToIgnore = new Set(["BODY", "HEAD", "HTML"]); // Shouldn't be used in templates.
			const tagsSupported = new Set(["A", "B", "BIG", "BLOCKQUOTE", "BR", "CENTER", "CODE", "DIV", "EM","FONT", "H1", "H2", "H3", "H4", "H5", "H6", "HR", "I", "IMG", "LI", "MARQUEE", "OL", "P", "PRE", "S", "SPAN", "STRIKE", "STRONG","SUB","SUP","TABLE","TBODY","TD","TH","TR","U","UL"]); // Supported by PB.
			const html5Warning = new Set(["BIG","FONT","MARQUEE","STRIKE","TT"]); // Supported by PB, but not HTML5.
			const tagsToRename = {"BR":"break"} // BBCode syntax is different.
			const tagsUnpaired = new Set(["IMG", "BR", "HR"]); // Don't have end tags.
			const useDivSpanFix = '[newclass="div.span"]display: inline-block;[/newclass]'

			var DOMTree = $.parseHTML( "<b></b>" );
			var BCCode = "";
			var importedCSS = "";
			var CSSBlocks = {}
			var linkCount = 0; // Number of external links currently loading -- must be 0 before writing
			var errors = new Set();
			var warnings = new Set();
			var useDivSpan = false;

			function convert(){
				// Clear globals from previous conversions.
				BCCode = "[nospaces]";
				importedCSS = "";
				warnings.clear();
				errors.clear();
				linkCount = 0;
				useDivSpan = false;
				CSSBlocks = {};

				// Parse & write results.
				var inputText = $("#html_in").val();
				parseHTMLCSS(inputText);
			}

			function writeResults(){
				$("#bbc_out").val(BCCode)
				$("#issues").html("");
				if(errors.size > 0 || warnings.size > 0){
					$("#issues").append("<b>ERRORS / WARNINGS:</b><br/>")
				}
				if(errors.size > 0){
					$("#issues").append("<div style='color: red;'>" + Array.from(errors).join('<br/><br/>') + "</div><br/>")
				}
				if(warnings.size > 0){
					$("#issues").append("<div style='color: orange;'>" + Array.from(warnings).join('<br/><br/>') + "</div>")
				}
			}

			function parseHTMLCSS(HTMLstring){
				DOMTree = $.parseHTML( HTMLstring )

            	console.log(DOMTree);

            	// Parse HTML elements, identify CSS
            	for(elemNum in DOMTree){
            		HTMLtoBCCode(DOMTree[elemNum]);
            	}

            	// Parse CSS
            	for(blockID in CSSBlocks){
            		console.log(blockID);
            		var newCSSBlock = '[div style="color: transparent; line-height: 0px;"]';
            		newCSSBlock = newCSSBlock + getCSSTags(CSSBlocks[blockID]);
            		newCSSBlock = newCSSBlock + "[/div]";
            		BCCode = BCCode.replace(blockID, newCSSBlock)
            	}
            	if(useDivSpan){ BCCode = BCCode + useDivSpanFix }

            	// Place any classes from LINK imports at the top
            	waitForLinkProcessing();
            	
			}

			function waitForLinkProcessing(func){
			    if(linkCount == 0){
			        console.log(importedCSS);
	            	if(importedCSS != ""){
	            		BCCode = '[div style="color: transparent; line-height: 0px;"]' + getCSSTags(importedCSS, true) + "[/div]" + BCCode;
	            	}
	            	writeResults();
			    }else{
			    	console.log(linkCount);
			        window.setTimeout(waitForLinkProcessing, 250);
			    }
			}

			function HTMLtoBCCode(elem){
				switch(elem.nodeName.toUpperCase()){
        			case "STYLE": 
        				var blockID = "XCSSLOCK-" + (Object.keys(CSSBlocks).length + 1) + "X";
        				BCCode = BCCode + blockID 
        				CSSBlocks[blockID] = elem.innerText;
        				break;
        			case "#TEXT":
        				BCCode = BCCode + elem.wholeText;
        				break;
        			case "#COMMENT":
        				// do nothing
        				break;
        			case "LINK":
        				BCCode = BCCode + getLinkTag(elem.href);
        				break;
        			default:
        				BCCode = BCCode + getBCCStartTag(elem)
        				if(elem.childNodes.length > 0){
        					for(var childElem = 0; childElem < elem.childNodes.length; childElem++){
			            		HTMLtoBCCode(elem.childNodes[childElem]);
			            	}
        				}
        				BCCode = BCCode + getBCCEndTag(elem)

        				if(!tagsSupported.has(elem.nodeName.toUpperCase())){
        					errors.add( elem.nodeName.toUpperCase() + " is not a supported element type.");
        				}
        		}
			}

			function getLinkTag(path){
				if(path.indexOf("fonts.googleapis") >= 0 ){ // confirm google font call
					return "[googlefont=" + path.substring(path.indexOf("family=")+7) + "]"
				}else if(path.indexOf(".css") >= 0){
					linkCount = linkCount + 1;
					console.log(path);
					if(path.trim().substring(0,5) == "file:"){
						path = "http:" + path.trim().substring(6);
					}
					$.get( path, function( css ) {
					  importedCSS = importedCSS + "\n" + css;
					  warnings.add('External resources from "link" tags are not supported, so the converter extracted the classes that are being used from ' + path);
					}).always(function() {
					  linkCount = linkCount - 1;
					});
				}else{
					errors.add('The only external resources allowed from "link" tags are .css files or Google Fonts.');
				}

				return "";
			}

			function getBCCStartTag(elem){
				tagText = "";
				classes = "";
				ids = "";
				
				if(tagsToIgnore.has(elem.nodeName.toUpperCase())){
					return "";
				}else if(html5Warning.has(elem.nodeName.toUpperCase())){
					warnings.add( elem.nodeName.toUpperCase() + ' tags are supported by the PB editor, but are <a href="https://caniuse.com/#search=deprecated%20HTML%20elements">not formally supported</a> by HTML5');
				}

				if(elem.nodeName.toUpperCase() in tagsToRename){
					tagText = tagText + "[" + tagsToRename[elem.nodeName.toUpperCase()];
				}else{
					tagText = tagText + "[" + elem.nodeName.toLowerCase();
				}

				var styleAttached = false;
				if(elem.attributes.length > 0){
					for(var attr = 0; attr < elem.attributes.length; attr++){
						switch(elem.attributes[attr].name.toUpperCase()){
							case "CLASS":
								classes = elem.attributes[attr].value.trim();
								break;
							case "ID":
								ids = elem.attributes[attr].value;
								break;
							case "STYLE":
								styleAttached = true;
							default:
								tagText = tagText + " " + elem.attributes[attr].name + "=" + '"' + elem.attributes[attr].value + '"';
						}
					}
				}
				if(elem.nodeName.toUpperCase() == "SPAN" && !styleAttached){ 
					warnings.add( elem.nodeName.toUpperCase() + ' tags without a style attribute will be removed in the ProBoards editor after editing or quoting the post. This converter has changed them to DIVs with the class .span' ); 
					useDivSpan = true;
					tagText = "[div" + tagText.substring(elem.nodeName.length + 1);
					classes = (classes + " span").trim();
					elem.nodeName = "DIV";
				}
				tagText = tagText + "]"

				if(classes != ""){
					tagText = tagText + '[attr="class","' + classes + '"]'
				}
				if(ids != ""){
					tagText = tagText + '[attr="id","' + ids + '"]'
				}
				if(elem.nodeName.toUpperCase() != "DIV" && (classes != "" || ids != "") ){
					if(tagsUnpaired.has(elem.nodeName.toUpperCase())){
						errors.add( elem.nodeName.toUpperCase() + " tags cannot be given a class or ID directly. Try surrounding it with a wrapper div." )
					}else if(tagsSupported.has(elem.nodeName.toUpperCase()) && !(elem.nodeName.toUpperCase() == "SPAN" && !styleAttached) ){
						warnings.add( "<b>Style Tag pluggin version 2.1.0</b> or later is required for [attr] tags to attach to " + elem.nodeName.toUpperCase() + " elements. Otherwise they will only attach to DIVs." )
					}
				}
				
				return tagText;
			}

			function getBCCEndTag(elem){
				if(tagsToIgnore.has(elem.nodeName.toUpperCase()) || tagsUnpaired.has(elem.nodeName.toUpperCase())){
					return "";
				}else{
					if(elem.nodeName.toUpperCase() == "SPAN" && elem.style.cssText == ""){
						// End tag fix for SPAN tags disappearing on quote/edit.
						return "[/div]"
					}else{
						return "[/" + elem.nodeName.toLowerCase() + "]"
					}
				}
			}

			function getCSSTags(css){
				return getCSSTags(css, false);
			}

			function getCSSTags(css, isSelective){
				css = css.replace(/(\r\n|\n|\r)/gm," ").trim() // replace all newline variants
				css = css.replace(/(\s+)/g," ").trim() // replace all duplicated spaces

				var i = 0;
				var lvl = 0;
				var className = "";
				var classStyle = "";
				var nestedBrackets = "";
				var stringStarter = "";
				BBCCSS = ""
				while( i < css.length ){
					// Check if currently reading a quoted string
					if(stringStarter == "" && ( css[i] == "'" || css[i] == '"' ) ){
						stringStarter = css[i];
					}else if(stringStarter != ""){
						if(css[i] == stringStarter){
							stringStarter = "";
						}
					}

					// Logic based on current character & level of {} tree
					if(css[i] == "{"){
						if(stringStarter == ""){ lvl = lvl + 1; }
						if(lvl > 1){classStyle = classStyle + css[i];}
					}else if(lvl == 0){
						className = className + css[i];
					}else if(css[i] == "}"){
						if(stringStarter == ""){ lvl = lvl - 1; }
						if(lvl > 0){
							classStyle = classStyle + css[i];
						}else{
							/*console.log(className.trim());
							console.log((className + " ").replace(/(:+[^\s,~<>]+)/g," ").trim());
							if(className.trim().substring(0,1) != "@"){
								console.log($(DOMTree).find((className.trim() + " ").replace(/(:+[^\s,~<>]+)/g," ")).length)
							}*/

							// Convert classes if needed.
							if(!isSelective || className.trim().substring(0,1) == "@" || $(DOMTree).find((className + " ").replace(/(:+[^\s,~<>]+)/g," ").trim()).length > 0 ){
								if(useDivSpan && (/\bspan\b/gi).test(className.toUpperCase()) ){
									// Duplicate this class for div.span as well as span
									var selectors = className.toLowerCase().split(",");
									for(selector in selectors){
										if((/\bspan\b/gi).test(selectors[selector])){
											className = className + "," + className.replace(/\bspan\b/gi,"div.span")
										}
									}
								}
								if(classStyle.indexOf("{") < 0 && className.trim().substring(0,1) != "@" && className.indexOf("[") < 0){
									BBCCSS = BBCCSS + '\n[newclass="' + className.trim() + '"]';
									BBCCSS = BBCCSS + classStyle.trim();
									BBCCSS = BBCCSS + "[/newclass]";
								}else{
									nestedBrackets = nestedBrackets + className.trim() + " {" + classStyle + "} "
								}
							}

							className = "";
							classStyle = "";
						}
					}else{
						classStyle = classStyle + css[i];
					}
					i = i + 1;
				}

				if( nestedBrackets != "" ){
					BBCCSS = BBCCSS + '\n[newclass="nullelem"]' + "} " + nestedBrackets.trim().substring(0,nestedBrackets.length-2) + "[/newclass]"
				}
				return BBCCSS;
			}

		</script>

		<style>
			body{
				background-color: #ebedf0;
				color: #313131;
				font: 12px Calibri, Arial, sans-serif;
				margin: 0px;
				padding: 0px;
			}
			label {
				font-weight: bold;
			}
			textarea {
				border: 1px solid #cdcdcd;
				border-radius: 5px;
				resize: none;
				display: block;
				box-sizing: border-box;
				width: 100%;
				height: 200px;
				padding: 15px;
				font: 12px Courier New, Courier, monospace;
			}
			button {
				margin-top: 3px;
				cursor: pointer;
				box-shadow: 0px 1px 0px 0px #f0f7fa;
				background:linear-gradient(to bottom, #33bdef 5%, #019ad2 100%);
				background-color:#33bdef;
				border-radius:6px;
				border:1px solid #057fd0;
				display:inline-block;
				cursor:pointer;
				color:#ffffff;
				font-family:Arial;
				font-size:15px;
				font-weight:bold;
				padding:5px 23px;
				text-decoration:none;
				text-shadow:0px -1px 0px #5b6178;
			}
			button:hover {
				background:linear-gradient(to bottom, #019ad2 5%, #33bdef 100%);
				background-color:#019ad2;
			}
			button:active {
				position:relative;
				top:1px;
			}
			.grouping { 
				margin: 0px 30px;
				margin-bottom: 20px; 
			}
			#banner {
				background-color: rgba(21,21,23,.95);
				color: #fff;
				padding: 10px;
				margin-bottom: 10px;
			}
			#banner h1, #banner h2 {
				margin: 0px;
			}
			#banner h1 {
				font: 800 2em / 1.2em Calibri, Arial, sans-serif;
			}
			#banner h2 {
				font: 1.2em / 1em Calibri, Arial, sans-serif;
			}

			#credits {
				margin: 0px 10px;
				font-size: 10px;
				letter-spacing: 1px;
			}
			#credits a {
				text-decoration: none;
				color: #79ade0;
			}
		</style>
	</head>
	<body>
		<div id="banner">
			<h1>[ BBCode Converter ]</h1>
			<h2>Converts HTML & CSS to ProBoards-friendly BBCode</h2>
		</div>

		<div class="grouping">
			<label>Input your HTML code here:</label>
			<textarea id="html_in">
<div class="stylinclass">
	Click the <b>"Convert"</b> button below to try it!
</div>

<style>
.stylinclass { 
	color: black; 
}

.stylinclass b {
	font-weight: bold;
}
</style></textarea>
			<button onclick="convert()">CONVERT!</button>
		</div>

		<div class="grouping">
			<label>Copy the ProBoards BBCode output from here:</label>
			<textarea id="bbc_out"></textarea>
		</div>

		<div class="grouping">
			<div id="issues"></div>
		</div>

		<div id="credits">
			Hi, my name is <a href="http://pixel-perfect.boards.net/user/240">Iceguin</a> -- I make codes sometimes.
			<br/>This page does not currently convert tabbed templates ;n;
		</div>
	</body>
</html>